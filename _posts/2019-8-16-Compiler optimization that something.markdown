---
layout: post
title: 编译优化的那点事
date: 发布于2019-08-16 17:45:16 +0800
categories: 测试结果杂记
tag: 4
---

* content
{:toc}

这几天遇到一个bug，在一个线程池中往缓冲区中写数据，测试同事反馈说是一用线程池程序就闪退，改成单线程就没事，程序反馈是产生11信号，经过几天排查，是编译器优化的锅，借此机会详细学习一下关于优化的编译选项
<!-- more -->


# 全局禁用优化

这个不用多废话，在编译选项上配置O1,O2什么的大家一定经常接触，就不多说了

# 局部禁用优化

## 函数禁用优化

为函数设置__attribute__((optimize(“O0”)))属性  
这个方法貌似只有gcc有效，由于本次的环境的windows下用ndk调用clang编译安卓的so，没有gcc环境，是否有效没有测试，但我的ndk环境是无效的，提示忽略了optimize的属性，其他编译器的函数优化选项没有找到。

## 代码段禁用优化

### gcc

    
    
    #pragma GCC push_options
    #pragma GCC optimize ("O0") 
    // your code
    #pragma GCC pop_options 
    

同样，由于没有gcc环境，这个并没有测试过

### vs

    
    
    #pragma optimize("", off)
    // your code
    #pragma optimize("", on)
    

虽然有测试环境，但由于我懒，这个同样没有测试

### clang

    
    
    #pragma clang optimize off
    // your code
    #pragma clang optimize on
    

这个测试过了，有效，我现在用的就是这个

## 变量禁用优化

变量禁用优化就是使用volatile关键字，这是原生关键字，不受编译环境的影响，下面简单介绍一下禁用优化的原理  
我们在代码中声明一个变量，编译器在编译的时候会对代码进行优化，一个比较常用的策略就是将经常用到的变量直接写到寄存器中，这样是比在内存中读取要快的，当变量在本线程中被改变，会被同步到寄存器中。但是，当变量被别的线程改变，或者寄存器被别的线程改变，就会导致在本线程内寄存器的值和变量的值不一致，从而造成程序错误，严重情况会使程序直接挂掉，我此次遇到的问题就是这个原因造成的  
如果我们在声明变量的时候使用volatile关键字，编译器就不会将变量存放在寄存器中，而是强行从内存中进行读取，这样就不会有数据不一致的情况出现

